# AOP란

Spring의 핵심 개념 중 하나인 DI가 애플리케이션 모듈들 간의 결합도를 낮춘다면, AOP(Aspect-Oriented Programming)는 핵심 로직과 부가 기능을 분리하여 **애플리케이션 전체에 걸쳐 사용되는 부가 기능을 모듈화하여 재사용할 수 있도록 지원**

기존에 OOP에서 바라보던 관점을 다르게 하여 부가기능적인 측면에서 보았을때 공통된 요소를 추출하는데, 이때 가로(횡단) 영역의 공통된 부분을 잘라냈다고 하여, AOP를 **크로스 컷팅(Cross-Cutting)** 이라고 부르기도 함

* OOP : 비즈니스 로직의 모듈화
	* 모듈화의 핵심 단위는 비즈니스 로직
* AOP : 인프라 혹은 부가기능의 모듈화
	* 대표적인 예 : 모니터링 및 로깅, 동기화, 오류 검사 및 처리, 성능 최적화(캐싱) 등
	* 각각의 모듈들의 주 목적 외에 필요한 부가적인 기능들
	
---

즉,  AOP는 **공통된 기능을 재사용하는 기법**

OOP에선 공통된 기능을 재사용하는 방법으로 상속이나 위임을 사용하지만 전체 애플리케이션에서 여기저기 사용되는 부가기능들은 상속이나 위임으로 처리하기에는 깔끔한 모듈화가 어렵기 대문에 AOP 가 등장

* AOP의 장점
	* 애플리케이션 전체에 흩어진 공통 기능이 하나의 장소에서 관리되어 유지보수가 좋음
	* 핵심 로직과 부가 기능의 명확한 분리로, 핵심 로직은 자신의 목적 외에 사항들에는 신경쓰지 않음
	
## AOP 적용 방식

* 컴파일 시점
	* .java 파일을 컴파일러를 통해 .class를 만드는 시점에 부가 기능 로직을 추가하는 방식
	* 모든 지점에 적용 가능
	* AspectJ가 제공하는 특별한 컴파일러를 사용해야 하기 때문에 특별할 컴파일러가 필요한 점과 복잡하다는 단점
* 클래스 로딩 시점
	* .class 파일을 JVM 내부의 클래스 로더에 보관하기 전에 조작하여 부가 기능 로직 추가하는 방식
	* 모든 지점에 적용 가능
	* 특별한 옵션과 클래스 로더 조작기를 지정해야하므로 운영하기 어려움
* 런타임 시점
	* 스프링이 사용하는 방식
	* 컴파일이 끝나고 클래스 로더에 이미 다 올라가 자바가 실행된 다음에 동작하는 런타임 방식
	* 실제 대상 코드는 그대로 유지되고 프록시를 통해 부가 기능이 적용
	* 프록시는 메서드 오버라이딩 개념으로 동작하기 때문에 메서드에만 적용 가능 -> 스프링 빈에만 AOP를 적용 가능
	* 특별한 컴파일러나, 복잡한 옵션, 클래스 로더 조작기를 사용하지 않아도 스프링만 있으면 AOP를 적용할 수 있기 때문에 스프링 AOP는 런타임 방식을 사용

---

## AOP 용어

* Join point
	* 추상적인 개념 으로 advice가 적용될 수 있는 모든 위치를 말합니다.
	* ex) 메서드 실행 시점, 생성자 호출 시점, 필드 값 접근 시점 등등..
	* 스프링 AOP는 프록시 방식을 사용하므로 조인 포인트는 항상 메서드 실행 지점
* Pointcut
	* 조인 포인트 중에서 advice가 적용될 위치를 선별하는 기능
	* 스프링 AOP는 프록시 기반이기 때문에 조인 포인트가 메서드 실행 시점 뿐이 없고 	* 포인트컷도 메서드 실행 시점만 가능
* Target
	* advice의 대상이 되는 객체
	* Pointcut으로 결정
* advice
	* 실질적인 부가 기능 로직을 정의하는 곳
	* 특정 조인 포인트에서 Aspect에 의해 취해지는 조치
		* around, before, afterReturning, afterThrowing, after
* Aspect
	* advice + pointcut을 모듈화 한 것
	* @Aspect와 같은 의미
* Advisor
	* 스프링 AOP에서만 사용되는 용어로 advice + pointcut 한 쌍
* Weaving
	* pointcut으로 결장한 타겟의 join point에 advice를 적용하는 것
* AOP 프록시
	* AOP 기능을 구현하기 위해 만든 프록시 객체
	* 스프링에서 AOP 프록시는 JDK 동적 프록시 또는 CGLIB 프록시
	* 스프링 AOP의 기본값은 CGLIB 프록시
