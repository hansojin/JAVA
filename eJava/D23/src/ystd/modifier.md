생성자의 접근 제어자를 private으로 지정하면, 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없게 된다. 

그래도 클래스 내부에서는 인스턴스를 생성할 수 있다.

```
class Singleton{
	private Singleton(){
		...
	}
	...
}
```

이처럼 생성자를 통해 직접 인스턴스를 생성하지 못하게 하고 public메서드를 통해 인스턴스에 접근하게 함으로써 사용할 수 있는 인스턴스의 개수를 제한할 수 있다.

또 한가지, 생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없다. 

왜냐하면, 자손클래스의 인스턴스를 생성할 때 조상클래스의 생성자를 호출해야만 하는데, 생성자의 접근 제어자가 private이므로 자손클래스에서 호출하는 것이 불가능하기 때문이다.

 그래서 클래스 앞에 final을 더 추가하여 상속할 수 없는 클래스라는 것을 알리는 것이 좋다.
 
 Math클래스는 몇 개의 상수와 static 메서드만으로 구성되어 있기 때문에 인스턴스를 생성할 필요가 없다. 
 
 그래서 외부로부터의 불필요한 접근을 막기 위해 다음과 같이 생성자의 접근 제어자를 private으로 지정하였다.

```
public final class Math{
	private Math() {}
	...
}
```

**제어자(modifier)의 조합**

|대상	|사용가능한 제어자|
|---|---|
|클래스|public, (default), final, abstract|
|메서드|모든 접근 제어자, final, abstract, static|
|멤버변수|모든 접근 제어자, final, static|
|지역변수|final|

**제어자를 조합해서 사용할 때 주의해야 할 사항**

1. 메서드에 static과 abstract를 함께 사용할 수 없다. *static 메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문이다.*
2. 클래스에 abstract와 final을 동시에 사용할 수 없다. *클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고 abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기 때문이다.*
3. abstract 메서드의 접근 제어자가 private일 수 없다. *abstract메서드는 자손 클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손클래스에서 접근할 수 없기 때문이다.*
4. 메서드에 private와 final을 같이 사용할 필요는 없다. *접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문이다. 이 둘 중 하나만 사용해도 의미가 충분하다.*

**이클립스 메소드 접근 제어자**
* Green Circle - public method
* Red Square - private method
* Yellow Diamond - protected method
* Blue Triangle - default (package visible) method

**접근 제한자** 

* public  
* protected : 같은 패키지 / 자식 클래스
* private : 말 그대로, 개인적인 것이라 외부에서 사용될 수 없도록 함

위 세가지 접근 제한자가 적용되지 않으면, default 접근 제한을 가짐

* default : 같은 패키지 소속된 클래스만 사용할 수 있음

**public > protected > default > private** 순으로 접근 제한이 강화된다

