* 소스 source 
	* 고급 언어로 작성된 내용

* 컴파일 compile 
	* 컴퓨터가 이해할 수 있도록 0과 1로 이루어진 기계어로 변환하는 과정

* 객체 지향 프로그래밍 OOP: Object Oriented Programming 
	* 프로그램을 개발하는 기법으로, 부품에 해당하는 객체들을 먼저 만들고 이것들을 하나씩 조립 및 연결해서 전체 프로그램을 완성하는 기법

* 자바 가상 기계 JVM: Java Virtual Machine
	* 자바 프로그램은 완전한 기계어가 아닌 중간 단계의 바이트 코드이기 때문에, 이것을 해석하고 실행할 수 있게 해주는 가상의 운영체제
	* JVM의 메모리 영역
		* 메소드 영역: 클래스(~.class)들을 클래스 로더로 읽어 클래스별로 런타임 상수 풀, 필드 데이터, 메소드 데이터, 메소드 코드, 생성자 코드 등을 분류해서 저장한다
		* 힙 영역: 객체와 배열이 생성되는 영역. JVM 스택 영역에서 생성된 변수나 다른 객체의 필드에서 이 곳에 있는 객체와 배열을 참조한다
		* JVM 스택 영역: 스레드마다 하나씩 존재. 스레드가 시작할 때마다 JVM 스택 영역이 할당된다
	
* 통합 개발 환경 IDE: Integrated Development Environment
	* 프로젝트 생성, 자동 코드 완성, 디버깅 기능을 제공하는 환경
		* ex) Eclipse(자바), Visual Studio(C/C++)

* 디버깅 debugging
	* 모의 실행을 해서 코드의 오류를 찾는 행위

* 변수 variable
	* 하나의 값을 저장할 수 있는 메모리의 공간. 프로그램에 의해서 수시로 값이 변동 될 수 있다. 하나의 변수에는 오로지 하나의 값만 저장할 수 있고, 자바에서는 선언된 변수에 한 가지 종류의 값만 저장할 수 있다.
		* 로컬 변수(지역 변수): 메소드 블록 내에서 선언된 변수. 로컬 변수는 메소드 실행이 끝나면 메모리에서 자동으로 없어진다.
		* 변수 선언: 어떤 식별자를 갖고, 어떤 데이터를 가지고 시작하는 변수라는 것을 알리는 것.
		* 할당 : 변수에 값을 넣거나 저장하는 것
		* 참조 : 변수에 접근 하는 것
	
* 유니코드 unicode
	* 세계 각국의 문자들을 코드값으로 매핑한 국제 표준 규약이다. 유니코드는 하나의 문자에 대해 하나의 코드값을 부여하기 때문에 영문 ‘A’ 및 한글 ‘가’도 하나의 코드 값을 가진다. 자바는 모든 문자를 유니코드로 처리한다.
		* 유니코드는 영문자 외에 전 세계의 문자를 표현할 수 있도록 설계된 반면 아스키(ASCII: American Standard Code for Information Interchange, 미국 정보 교환 표준 부호) 코드는 7비트로 표현되는 영문자 기반 인코딩이다. 유니코드의 앞부분은 아스키 문자로 할당되어 있다.
	
* 자료형 data type
	* 자료의 형태. 자료형에 따라 컴퓨터가 어떻게 처리하는지 달라진다. 자바에서는 기본 타입과 참조 타입으로 구분됨
	
* 기본 타입 primitive type
	* 원시 타입이라고도 한다. 정수, 실수, 문자, 논리 리터럴을 저장하는 자료형
	
* 참조 타입 reference type
	* 객체의 번지를 참조하는 타입. 배열, 열거, 클래스, 인터페이스 타입이 있다.
		* 값에 의한 호출(call by value)과 참조에 의한 호출(call by reference)
			* 값에 의한 호출을 할 땐 메소드가 전달인자를 복사하여 사용하고,메소드 실행이 종료되면 반환하는 방식이기 때문에 전달인자를 직접 수정하는 것이 의미가 없다.참조란 대상의 주소값을 통해 접근하는 것이고, 참조에 의한 호출은 메소드가 전달인자로 주소값을 넘겨받아 해당 위치에 있는 값에 접근하여 다른 곳에서 쓰일 수 있도록 수정할 수 있다. 자바에서는 무조건 call by value인 것이 아닌가 싶지만, 전달인자로 받은 데이터의 타입에 따라 그 값value이 주소값이 되기도 하고, 객체가 가리키는 값이 되기도 한다.
	
* 조건문 conditional statement
	* 특정 조건을 만족할 때 코드를 실행하는 문법 
		* if, else-if, else
		* infinite loop (for(;;), while(true))
	
* 쓰레기 수집기 garbage collector
	* 쓰레기 수집은 메모리 관리 기법 중 하나이다. 자바에선 JVM의 쓰레기 수집기를 이용해 자동적으로 사용하지 않는 객체를 메모리에서 제거한다.
		* 쓰레기 수집기가 객체를 제거하기 전에 중요한 데이터를 저장하고 싶을 때, 클래스 내에 객체 소멸자(finalize())를 재정의하여 객체가 소멸될 때 실행할 코드를 입력할 수 있다.
	
* null
	* 참조 타입 변수가 객체를 참조하지 않는다는 의미의 값. null값도 초기값으로 사용할 수 있기 때문에 null로 초기화된 참조 변수는 스택 영역에 저장된다.
	
* 인스턴스 instance
	* 클래스로부터 만들어진 객체
		* 인스턴스 멤버란 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말한다. 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부른다. 정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다. 이들을 각각 정적 필드, 정적 메소드라고 부른다. 정적 멤버는 객체가 아닌 클래스에 소속된 멤버이기 때문에 클래스 멤버라고도 한다.
	
* 생성자 constructor
	* new 연산자로 호출되는 특별한 중괄호 블록. 객체 생성 시 객체를 초과하는 역할을 한다. 메소드와 비슷하게 생겼지만, 클래스 이름으로 되어 있고 반환형이 없다. 객체 초기화란 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 하는 것을 말한다.
	
* 싱글톤 Singleton
	* 전체 프로그램에서 하나의 클래스에 단 하나의 객체만 만들도록 보장해야 하는 경우에 사용하는데, 이 때 생성된 객체를 싱글톤이라고 부른다. 생성자를 호출한 만큼 객체가 생성되기 때문에 클래스 외부에서 new 연산자로 생성자를 호출할 수없도록 막아야 한다. 생성자 앞에 private 접근 제한자를 붙이고, 필드에 자기 자신의 객체를 static으로 선언하면 된다.
	
* 상수 constant value
	* 값을 한 번 저장하면 변경할 수 없는 변수. 상수의 이름은 모두 대문자로 작성하는 것이 관례이다. 서로 다른 단어가 혼합된 이름이라면 언더바( _ )로 단어들을 연결해준다.
	
* 접근 제한자 access modifier
	* 객체의 필드와 메소드의 사용 범위를 제한하여 외부로부터 보호한다. 캡슐화된 멤버를 노출시킬 것인지, 숨길 것인지를 결정하기 위해 접근 제한자를 사용한다.
		* Getter and Setter : 외부에서 마음대로 읽고 변경할 수 없도록 제어하는 메소드로 필드에 직접 접근하지 않고 데이터를 조회, 수정할 수 있도록 하는 역할을 한다. 만약 외부에서 필드값을 읽을 수만 있고 변경하지못하도록 하려면(읽기 전용) Getter 메소드만 선언하거나, 아니면 Setter 메소드를 필요에 따라 private 혹은 protected 접근 제한을 갖도록 선언하면 된다.
	
* 상속 inheritance
	* 상위(부모) 객체를 기반으로 하위(자식) 객체를 생성하는 관계를 말한다. 상위 객체는 자기가 가지고 있는 필드와 메소드를 하위 객체에게 물려주어 하위 객체가 사용할 수 있도록 한다. 일반적으로 상위 객체는 종류를 의미하고, 하위 객체는 구체적인 사물에 해당한다. 자식 클래스를 선언할 때 어떤 부모 클래스를 상속받을 것인지 결정한다.
		* 부모(parent class, super class / 상위 클래스): 해당 클래스에 선언된 변수와 함수를 물려주는 클래스
		* 자식(child class, sub class / 하위 클래스): 다른 클래스로부터 물려받고자하는 클래스

	
* 오버라이딩 overriding
	* 부모에게서 상속받은 메소드의 내용이 자식 클래스에 맞지 않을 경우, 자식 클래스에서 동일한 메소드를 재정의하는 것
	
* 다형성 polymorphism
	* 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다. 코드측면에서 보면 다형성은 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해준다.
	
* 추상 클래스 abstract class
	* 실체 클래스가 공통적으로 가져야 할 필드와 메소드들을 정의해 놓은 추상적인 클래스. 추상 클래스는 실체 클래스의 공통되는 필드와 메소드를 추출해서 만들었기 때문에 객체를 직접 생성해서 사용할 수 없다.
	
* 중첩 클래스 nested class
	* 클래스 내부에 선언한 클래스. 두 클래스의 멤버들에 서로 쉽게 접근 할 수 있고, 외부에는 불필요한 관계 클래스를 감춤으로써 코드의 복잡성을 줄일 수 있다.
		* 멤버 클래스: 클래스의 멤버로써 선언되는 중첩 클래스
		* 로컬 클래스: 메소드 내부에서 선언되는 중첩 클래스
	
* 익명 객체 anonymous object
	* 이름이 없는 객체를 말한다. 익명 객체를 만들려면 어떤 클래스를 상속하거나 인터페이스를 구현해야 한다.
	
* 예외 exception
	* 사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 인해 발생하는 프로그램 오류
	
* 예외 처리 exception handling
	* 일반적으로 프로그램이 처리되는 동안 특정한 문제가 일어났을 때 처리를 중단하고 다른 처리를 하는 것. 자바에서는 예외exception라고 부르는 오류를 처리하는 과정을 말하기도 한다.
		* 일반 예외: 컴파일러 체크 예외라고도 한다. 만약 예외 처리 코드가 없다면 컴파일 오류가 발생한다. 일반 예외는 Exception을 상속받지만 RuntimeException은 상속받지 않는다.
	
* 스레드 thread
	* 한 가지 작업을 실행하기 위해 순차적으로 실행할 코드를 실처럼 이어 놓았다고 해서 유래된 이름. 하나의 스레드는 하나의 코드 실행 흐름이기 때문에 한 프로세스 내에 스레드가 두 개라면 두 개의 코드 실행 흐름이 생긴다는 의미
		* 동시성concurrency, 병렬성parallelism : 멀티 스레드는 동시성 또는 병렬성으로 실행된다. 동시성은 멀티 작업을 위해 하나의 코어에서 멀티 스레드가 번갈아가며 실행하는 성질을 말하고, 병렬성은 멀티 작업을 위해 멀티 코어에서 개별 스레드를 동시에 실행하는 성질을 말한다.
	
* 스택 stack
	* 후입선출(LIFO: Last In First Out) 자료구조. 
	* 나중에 넣은 객체가 먼저 빠져나간다.
	
* 큐 queue
	* 선입선출(FIFO: First In First Out) 자료구조. 
	* 먼저 넣은 객체가 먼저 빠져나간다.
	
* 스트림 stream
	* 프로그램이 외부 파일, 외부 네트워크 등과 통신할 때 데이터가 흐르는 길. 이 때 외부란 같은 컴퓨터 내부라도 프로그램의 바깥에 별도로 존재하는 것을 말한다.
	
* 버퍼 buffer
	* 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역. 버퍼는 큐의 한 형태로, 요청된 자료는 버퍼에 도착한 순서대로 처리된다.
	
