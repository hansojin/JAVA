### stream이란?

스트림의 사전적 의미는 '흐르다' 또는 '개울'입니다. 프로그래밍에서의 스트림도 사전적 의미와 크게 다르지 않습니다. 다만, 여기서는 물이 흐르는 것은 아니고 '데이터의 흐름'을 말합니다.

뭔가 추상적으로는 대충 데이터가 흐르겠구나.. 싶은데 정확히 어떻게 흐르고 결과를 이용하는지 알기가 어렵습니다. 그래서 제가 이해를 돕기 위한 그림을 준비하였습니다.

![stream](https://github.com/hansojin/JAVA/assets/112622663/395337ee-3ada-43b9-b760-2dff107ba3fe)

위 그림은 어부가 물고기를 그물로 잡고, 여러 마리를 일정한 기준으로 모아서 상자에 넣고, 이들을 하나로 모은 뒤 트럭에 실어서 우리의 밥상(?)까지 운반하는 과정을 나타내고 있습니다.

stream도 이와 별반 다르지 않습니다. 물고기와 같은 어류의 이동을 stream이라고 정의할 수 있습니다.

먼저, 어부가 어류 중에서도 고등어를 잡고 싶어서 그물로 고등어를 잡았습니다. 이 행위를 **filter** 라고 하고, 이 연산자를 **중간 연산자** 라고 합니다.

그리고 고등어를 포장하지 않고 생으로 팔 수는 없기 때문에 상자에 담아야 합니다. 이 행위를 **map** 이라고 하고, 이 연산자도 마찬가지로 **중간 연산자** 라고 합니다.

마지막으로, 고등어가 실린 수많은 상자를 운반하여 다른 곳으로 이동하면서 끝이 납니다. 이 행위를 **collect** 라고 하고, 이 연선자는 **최종 연산자** 라고 합니다.

어떤가요, 이제 조금 감이 잡히지 않나요? 스트림은 수많은 데이터의 흐름 속에서 각각의 원하는 값을 가공하여 최종 소비자에게 제공하는 역할을 한다고 보면 되겠습니다.

### Stream의 특징

위의 스트림을 이제 조금 딱딱하게 설명할 때가 왔습니다. 기능적인 측면에서 스트림은 컬렉션(배열 포함)의 저장 요소를 하나씩 참조해서 람다식으로 처리할 수 있도록 해주는 반복자입니다.

우리는 사실 반복자를 스트림이 아니더라도 계속 사용해 왔습니다. 단적인 예로 Iterator 반복자가 있죠.

```
public static void main(String[] args) {
    List<Integer> list = Arrays.asList(1, 2, 3);
    Iterator<Integer> it = list.iterator();
    while (it.hasNext()) {
      int num = it.next();
      System.out.println(num);
    }
```

정수가 있는 리스트를 하나씩 순회하면서 값을 출력하는 단순한 코드입니다. 이제, 이를 스트림으로 바꿔 보겠습니다.

```
public static void main(String[] args) {
    List<Integer> list = Arrays.asList(1, 2, 3);
    Stream<Integer> stream = list.stream();
    stream.forEach(System.out::println);
  }
```

어떤가요? 무슨 말인지는 모르겠어도 코드가 확 간결해졌다는 것을 아실 수 있을겁니다. 사실 저기서도 굳이 Stream을 변수로 따로 빼지 않고 바로 출력을 해도 되지만, 스트림을 정의하는 방식 중 하나를 보여주려고 일부러 한 줄을 더 코딩하였습니다.

이제, 스트림의 특징이 무엇인지 알아 보겠습니다.

1. 람다식으로 요소 처리 코드를 제공한다.
	* 위의 코드에서 볼 수 있듯이, 스트림은 람다식 또는 메소드 참조를 이용합니다. 따라서, 코드가 간결해지는 장점이 있습니다.
	
2.  내부 반복자를 사용하므로 병렬 처리가 쉽다.
	* 외부 반복자란 개발자가 코드로 직접 컬렉션의 요소를 반복해서 가져오는 코드 패턴을 말합니다. 우리가 흔히 사용하는 index를 이용한 반복문이나 Iterator를 사용한 while문은 모두 외부 반복자를 이용하는 것입니다. 반면, 내부 반복자는 컬렉션 내부에서 요소들을 반복시키고, 개발자는 요소당 처리해야 할 코드만 제공하는 코드 패턴을 말합니다.
	
![iter](https://github.com/hansojin/JAVA/assets/112622663/09c2211a-2f28-4e0f-8a5b-d6c2788c9398)

위의 그림은 외부 반복자와 내부 반복자를 나타낸 것입니다. 내부 반복자는 요소들의 변경 순서를 변경하거나, 멀티 코어 CPU를 최대한 활용하기 위해서 요소들을 분배시켜 병렬 작업을 할 수 있도록 도와 줍니다.

![iter2](https://github.com/hansojin/JAVA/assets/112622663/7407acb5-35aa-4622-9b4b-8c198d3dcc3e)

스트림은 람다식으로 요소 처리 내용만 전달할 뿐, 반복은 컬렉션 내부에서 일어납니다. 따라서, 요소의 병렬 처리가 컬렉션 내부에서 처리되므로 효율적인 병렬 처리가 가능합니다.

3. 중간 처리와 최종 처리가 존재한다.
	* 스트림은 컬렉션의 요소에 대해 중간 처리와 최종 처리를 수행할 수 있는데, 중간 처리에서는 매핑, 필터링, 정렬을 수행하고 최종 처리에서는 반복, 카운팅, 평균, 총합 등의 집계 처리를 수행합니다.
	* 만약, 학생 객체를 요소로 가지는 컬렉션이 있다고 가정하면, 중간 처리에서 학생의 수학 점수를 뽑아 내고 최종 처리에서는 수학 점수의 평균값을 산출하는 행위를 할 수 있습니다.
	
	
---

### Stream을 생성하는 방법

1. Collection으로 부터 스트림 얻기

	* 컬렉션으로는 주로 List를 쓰는데 리스트를 정의하고, 내장된 메소드인 stream()을 이용하면 됩니다.
	* 만약, 학생 객체를 저장하는 studentList를 정의하였다면, 아래와 같이 스트림을 얻어올 수 있습니다 
		* Stream<Student> stream = studentList.stream();
	* 그리고 정의한 stream을 이용하여 여러 가지 중간 처리나 최종 처리 작업을 하면 됩니다. 또한, 여기서 studentList.stream()과 같이 처음 얻어온 스트림을 오리지널 스트림이라고 부릅니다.
	
2. 배열로부터 스트림 얻기
	* 배열도 컬렉션에서 스트림을 얻어오는 것과 비슷합니다. 이번에는 학생의 이름을 저장하는 nameArr이 있다고 합시다. 그렇다면, 아래와 같이 배열로부터 스트림을 얻어올 수 있습니다.
	* 가변 인자를 사용 ->  Stream.of() 메소드를 통해 즉석으로 원하는 값을 집어 넣음으로써 스트림을 생성할 수 있습니다.
		* Stream<String> stream = Stream.of("a", "b", "c"); // 가변 인자
		* IntStream stream = IntStream.of(1, 2, 3); // 가변 인자
	* Arrays.stream() 메소드를 이용하여 스트림을 얻어오기
		* Stream<String> stream = Arrays.stream(nameArr);
		

3. 숫자 범위로부터 스트림 얻기
	* 위와 같이 컬렉션이나 배열을 정의하여 스트림을 얻어올 수도 있지만, 단순하게 1 ~ 100까지의 정수가 담긴 스트림을 얻고 싶을 때는 range() 또는 rangeClosed() 메소드를 사용하면 됩니다.
	* range()는 [a, b)로 끝 구간이 열린 구간이지만, rangeClosed()는 [a, b]로 끝 구간이 닫힌 구간인 차이입니다.
	* 컬렉션이나 배열 없이도 바로 1 ~ 100까지의 정수가 담긴 스트림을 얻어오기
		* IntStream stream = IntStream.rangeClosed(1, 100);
	
4. 빈 스트림 얻기
	* 일단 빈 스트림만 선언해 놓고 싶을 경우에
		* Stream<T> stream = Stream.empty();

5. 람다식으로 스트림 생성하기 - iterate()
	* iterate() 메소드는 for문과 비슷한 구조를 갖는데, 매개 변수로 초기값, Predicate<T>, UnaryOperator<T>를 사용합니다. 여기서 Predicate<T>는 선택
		* Stream<Integer> stream = Stream.iterate(0, n -> n + 1).limit(5);
		* Stream<Integer> stream = Stream.iterate(0, n -> n < 5, n -> n + 1);
	* 그런데, iterate() 메소드를 사용할 때 주의할 점이 있습니다. 바로, 제한 범위를 정해주어야 한다는 것입니다. 만약 이를 설정하지 않는다면, 무한정 값이 할당됩니다.
	* 따라서, limit() 메소드를 사용하거나 Pridicate<T>를 이용하여 위 문제를 해결할 수 있습니다.

6. 람다식으로 스트림 생성하기 - generate()
	* generate() 메소드는 매개 변수로 오직 Supplier<T>만을 갖습니다. 그런데, Supplier<T>는 매개 변수를 필요로 하지 않으므로 generate() 메소드는 결국 스트림 생성시 별도의 인수가 필요하지 않을 때 사용됩니다.
		* Random random = new Random();
		* IntStream.generate(() -> random.nextInt(45) + 1).limit(6);

---

### Stream 파이프라인

스트림은 데이터의 필터링, 매핑, 정렬, 그룹핑 등의 중간 처리와 합계, 평균, 카운팅, 최댓값, 최솟값 등의 최종 파이프라인으로 해결합니다. 여기서, 파이프라인은 컴퓨터 과학에서 한 데이터 처리 단계의 출력이 다음 단계의 입력으로 이어지는 형태로 연결된 구조를 말합니다. 최종 처리 스트림과 오리지널 스트림을 제외한 나머지 스트림은 중간 처리 스트림으로 볼 수 있습니다.

![pipe](https://github.com/hansojin/JAVA/assets/112622663/6b7cf507-17a0-4b9f-b0a6-c40787d89aaf)

위의 그림을 보시면 알 수 있듯이, **이전 데이터 처리의 출력이 다음 단계의 입력으로 이어집니다** . 좀 더 구체적으로 말하자면, 스트림 인터페이스에는 필터링, 매핑, 정렬 등의 많은 중간 처리 메소드가 있는데, 이 메소드들은 중간 처리된 '스트림'을 리턴합니다. 그리고 이 스트림에서 다시 중간 처리 메소드를 호출해서 파이프라인을 형성하게 됩니다.

스트림 파이프라인에는 한 가지 중요한 특징이 있습니다. 바로 **지연(lazy)** 인데요, 중간 스트림이 생성될 때 요소들이 바로 중간 처리되는 것이 아니라 최종 처리가 시작 되기 전까지 중간 처리는 지연이 됩니다. 최종 처리가 시작이 되어야 비로소 컬렉션의 요소가 하나씩 중간 스트림에서 처리가 되고 최종 처리까지 오게 되는 것이죠.







