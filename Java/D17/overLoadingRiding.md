## Method Overloading
---
* **매개변수의 개수/타입이 다른 같은 이름의 메소드를 정의**하는 것
	* ex) void print(), void print(String a), String pring(int a), String pring(int a, int b)
* 접근 제어자도 자유롭게 지정 가능 (접근 제어자만 다르면 오버로딩 가능하지 않음)
* 리턴값만 다른 것은 오버로딩을 할 수 없음
* 같은 클래스 내에서 적용


## Method Overriding
---
* 자식 클래스가 부모 클래스로부터 **상속받은 메소드를 재정의**하는 것
	* 상속 받은 메소드를 그대로 사용할 수도 있지만, 자식 클래스에서 상황에 맞게 변경해야하는 경우 오버라이딩할 필요가 생김
* **메소드의 이름, 매개변수, 리턴값이 모두 같아야 함**

### @Override의 용도 
---
* __어노테이션(annotation)__ ≒ 주석
* 주석인데 검증하는 기능을 하는 주석
* @Override는 오버라이딩을 검증하는 기능을 해서, 코드상 검사했을때 실제로 오버라이딩이 시행되지 않으면, 컴파일시 오류 출력

### Override의 접근제어자 설정 규칙 
---
1. 자식 클래스에서 오버라이딩하는 메소드의 접근 제어자는 부모 클래스보다 더 좁게 설정할 수 없다.
	* 만약 부모클래스의 접근제어자는 default로 설정되어 있으면, 자식 클래스들은 default보다 같거나 더 넓은 범위의 접근제어자만 설정할 수 있음 ( default, protected, public의 접근 제어자 세 개 사용 가능)

2. 예외(Exception)는 부모 클래스의 메소드 보다 많이 선언할 수 없다.
	* 부모 클래스에서 어떤 예외를 throws 한다고 하면, 자식 클래스에서는 그 예외보다 더 큰 범위의 예외를 throws할 수 없음

3. static메소드를 인스턴스의 메소드로 또는 그 반대로 바꿀 수 없음
	* 부모 클래스의 static메소드를 자식에서 같은 이름으로 정의할 수 있지만 이것은 다시 정의하는 것이 아니라 같은 이름의 static메소드를 새로 정의하는 것
	* static method는 override될 수 없는데, static method는 class(class영역)에 묶여 있고, instance method는 Object(heap영역)에 묶여있기 때문임

### 상속에서의 생성자
---
* 생성자는 상속이 되지 않음
* 대신, 자식클래스로 인스턴스를 생성할 때, 부모 클래스의 **기본 생성자를 자동으로 호출** 하게 됨
* **매개변수를 갖는 부모 클래스** 의 생성자는 자동으로 호출되지 않음
* 자식 생성자의 첫줄에 **super()** 키워드를 통해 부모 생성자의 매개변수와 동일한 타입을 매개값으로 작성해야 함















